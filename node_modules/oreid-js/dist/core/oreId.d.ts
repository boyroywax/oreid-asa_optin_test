import { ApiCustodialMigrateAccountParams, ApiCustodialNewAccountParams, ApiGetAppTokenParams } from '../api';
import { Auth } from '../auth/auth';
import { ApiEndpoint, AppAccessToken, AppAccessTokenMetadata, ChainNetwork, ExternalWalletType, NewAccountResult, ProcessId, RequestType, SignResult, SignStringParams, TransactionData, WebWidgetProps } from '../models';
import { PopupPlugin } from '../plugins';
import Transaction from '../transaction/transaction';
import TransitHelper from '../transit/TransitHelper';
import LocalState from '../utils/localState';
import IOreidContext from './IOreidContext';
import { OreIdOptions } from './IOreIdOptions';
export default class OreId implements IOreidContext {
    constructor(options: OreIdOptions);
    private _auth;
    private _initializerPlugins;
    private _isInitialized;
    private _localState;
    private _options;
    private _popup?;
    private _settings;
    private _transitHelper;
    isBusy: boolean;
    /** Names of all Transit providers installed (provided to this constructor) */
    transitProvidersInstalled: ExternalWalletType[];
    /** accessToken (stored in localState) */
    get accessToken(): string;
    /** accessToken helper functions and current state */
    get accessTokenHelper(): import("../auth/accessTokenHelper").AccessTokenHelper;
    /** authentication flows and login state */
    get auth(): Auth;
    /** whether the current appId is a demo app */
    get isDemoApp(): boolean;
    /** whether init() has been called */
    get isInitialized(): boolean;
    /** helper to persist data (e.g. accessToken) */
    get localState(): LocalState;
    /** oreid options used in constructor */
    get options(): OreIdOptions;
    /** installed popup plugin */
    get popup(): PopupPlugin;
    /** If we're running in the browser, we must use a proxy server to talk to OREID api
    Unless, we are running the demo app, in which case CORS is disabled by OREID server */
    get requiresProxyServer(): boolean;
    /** Transit wallet plugin helper functions and connections */
    get transitHelper(): TransitHelper;
    /** perform asynchronous setup tasks */
    init(): Promise<void>;
    /** throw and error if oreId is not initialized yet */
    private assertIsInitialized;
    /** Retrieve settings for all chain networks defined by OreId service
     * and caches the result */
    getAllChainNetworkSettings(): Promise<import("../models").SettingChainNetwork[]>;
    /** Returns config for specified chain network */
    getChainNetworkSettings(chainNetwork: ChainNetwork): Promise<import("../models").SettingChainNetwork>;
    /** Clears user's accessToken and user profile data */
    logout(): void;
    /** Sign an arbitrary string (instead of a transaction)
     *  NOTE: Currently this only supports Transit wallets - not OREID siging
     */
    signStringWithWallet(params: SignStringParams): Promise<{
        signedString: string;
    }>;
    /** Create a new user account that is managed by your app
     * Requires a wallet password (userPassword) on behalf of the user
     * Requires an apiKey with the createUser right
     * Returns: accountName of newly created account
     *       OR errorCode, errorMessage, and message if any problems */
    custodialNewAccount(accountOptions: ApiCustodialNewAccountParams): Promise<import("../api").ApiCustodialNewAccountResult>;
    /** Call the custodial/migrate-user api
     * Converts a user account to a new account type
     * Usually used to convert a virtal account to a native account (on-chain)
     * .. and expects the account to be a managed (custodial) account
     * Requires a wallet password (userPassword) on behalf of the user
     * Requires an apiKey with the accountMigration right
     * Returns: account name of migrated account
     *       OR errorCode, errorMessage, and message if any problems */
    custodialMigrateAccount(migrateOptions: ApiCustodialMigrateAccountParams): Promise<import("../api").ApiCustodialMigrateAccountResult>;
    /** Return ChainNetwork that matches chainId (as defined in OreId Chain Network Settings) */
    getChainNetworkByChainId(chainId: string): Promise<ChainNetwork>;
    /** Returns metadata about the external wallet type (e.g. name, logo) and which features it supports */
    geExternalWalletInfo(walletType: ExternalWalletType): import("../transit/transitProviders").TransitProviderAttributes;
    /** Create a new Transaction object - used for composing and signing transactions */
    createTransaction(data: TransactionData): Promise<Transaction>;
    /** Call the setBusyCallback() callback provided in optiont
     *  Use true or false to set the current busy state
     */
    setIsBusy(value: boolean): void;
    /**  Validates startup options */
    validateAndSetOptions(options: OreIdOptions): void;
    /** Gets a single-use token to access the service */
    getAppAccessToken(params?: ApiGetAppTokenParams): Promise<string>;
    /** Extracts the response parameters on the /new-account callback URL string */
    handleNewAccountResponse(callbackUrlString: string): NewAccountResult;
    /** Extracts and returns the response parameters from the /sign callback URL string */
    handleSignCallback(callbackUrlString: string): SignResult;
    /** Updates and returns a WebWidgetProps object to include two new fields: timestamp, signature
     *  timestamp: current server time
     *  signature: HMAC signature of the object including the timestamp - calculated using the apiKey
     *  IF incoming props already has a value for timestamp - it is kept
     *  If both incoming and timestamp and signature are already present, this returns incoming data unmodified
     *  If an apiKey is not provided in options, this function expects a proxy server endpoint at /oreid/hmac to generate the siganture with the secured apiKey
     *  Returns the updated object that includes the timestamp and the signature fields
     */
    appendTimestampAndSignatureToWidgetProps(data: WebWidgetProps): Promise<WebWidgetProps>;
    /** Helper function to call api endpoint and inject api-key
      here params can be query params in case of a GET request or body params in case of POST request
      processId (optional) - can be used to associate multiple calls together into a single process flow
    */
    callOreIdApi(requestMethod: RequestType, endpoint: ApiEndpoint, params?: {
        [key: string]: any;
    }, 
    /** Required if apiKey is not provider (optional otherwise) */
    overrideAccessToken?: string, processId?: ProcessId): Promise<any>;
    /** Add an app access token and hmac signature to the url
     *  If running in browser, calls proxy server at /oreid/prepare-url to do both (since they require teh apiKey secret) */
    addAccessTokenAndHmacToUrl(urlString: string, appAccessTokenMetadata: AppAccessTokenMetadata, overrideAppAccessToken?: AppAccessToken): Promise<string>;
}
